package picker

import (
	"testing"
)

func TestBuf_getCrc(t *testing.T) {
	buf := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA}
	crc := buf.getCrc()
	if crc[0] != 0xC3 || crc[1] != 0xAA {
		t.Error("Expected 195 170, got", crc[0], crc[1])
	}
}

func TestBuf_AddCrc(t *testing.T) {
	buf := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA}
	res := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA, 0xC3, 0xAA}
	buf = buf.AddCrc()
	for i := range res {
		if res[i] != buf[i] {
			t.Error("don't match")
		}
	}
}

func TestBuf_RemoveCrc(t *testing.T) {
	buf := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA, 0xC3, 0xAA}
	res := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA}
	buf = buf.RemoveCrc()
	for i := range res {
		if res[i] != buf[i] {
			t.Error("don't match")
		}
	}
}

func TestBuf_CheckCrc(t *testing.T) {
	buf := Buf{0x00, 0x55, 0xAA, 0x55, 0xAA, 0xC3, 0xAA}
	if !buf.CheckCrc() {
		t.Error("expected true, got false")
	}
	bufWrong := Buf{0x00, 0x55, 0xAA, 0x55, 0xA1, 0xC3, 0xAA}
	if bufWrong.CheckCrc() {
		t.Error("expected false, got true")
	}
}

func TestBuf_Slip(t *testing.T) {
	buf := Buf{0x00, 0x55, 0xAA, 0xC0, 0x55, 0xAA, 0xC3, 0xAA}
	res := Buf{0xC0, 0x00, 0x55, 0xAA, 0xDB, 0xDC, 0x55, 0xAA, 0xC3, 0xAA, 0xC0}
	encoded := buf.Slip()
	for i := range res {
		if res[i] != encoded[i] {
			t.Error("don't match")
		}
	}
}

func TestBUF_UnSlip(t *testing.T) {
	buf := Buf{0xC0, 0x00, 0x01, 0x00, 0x80, 0xC7, 0x41, 0x10, 0x60, 0x3B, 0x4F, 0x00, 0x08, 0x00, 0xDB, 0xDC, 0x2A, 0x39, 0xC0}
	res := Buf{0x00, 0x01, 0x00, 0x80, 0xC7, 0x41, 0x10, 0x60, 0x3B, 0x4F, 0x00, 0x08, 0x00, 0xC0, 0x2A, 0x39}
	decoded, err := buf.UnSlip()
	for i := range res {
		if res[i] != decoded[i] {
			t.Error("don't match")
		}
	}
	if err != nil {
		t.Error("err must be nil")
	}
	wrongBuf := Buf{0x00, 0x01, 0x00, 0x80, 0xC7, 0x41, 0x10, 0x60, 0x3B, 0x4F, 0x00, 0x08, 0x00, 0xDB, 0xDC, 0x2A, 0x39, 0xC0}
	decodedWrong, wrongErr := wrongBuf.UnSlip()
	if len(decodedWrong) != 0 {
		t.Error("must be 0")
	}
	if wrongErr == nil {
		t.Error("err must not be nil")
	}
}

func TestBuf_ToString(t *testing.T) {
	buf := Buf{0xC0, 0x00, 0x01, 0x00, 0x80, 0xC7, 0x41, 0x10, 0x60, 0x3B, 0x4F, 0x00, 0x08, 0x00, 0xDB, 0xDC, 0x2A, 0x39, 0xC0}
	res := "C0 00 01 00 80 C7 41 10 60 3B 4F 00 08 00 DB DC 2A 39 C0"
	if buf.ToString() != res {
		t.Error("must be equal")
	}
}